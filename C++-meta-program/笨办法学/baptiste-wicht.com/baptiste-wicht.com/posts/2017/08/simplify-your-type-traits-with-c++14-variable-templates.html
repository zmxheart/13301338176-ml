<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Simplify your type traits with C++14 variable templates | Blog blog("Baptiste Wicht");</title>
<script src="/cdn-cgi/apps/head/98vpnawSZZMscPn4oDND-ZgswjM.js"></script><link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="http://baptiste-wicht.com/posts/2017/08/simplify-your-type-traits-with-c%2B%2B14-variable-templates.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Baptiste Wicht">
<link rel="prev" href="how-to-fix-mdadm-raid5-raid6-growing-stuck-at-0ks.html" title="How to fix mdadm RAID5 / RAID6 growing stuck at 0K/s ?" type="text/html">
<link rel="next" href="../09/cpp11-concurrency-tutorial-futures.html" title="C++11 Concurrency Tutorial - Part 5: Futures" type="text/html">
<meta property="og:site_name" content='Blog blog("Baptiste Wicht");'>
<meta property="og:title" content="Simplify your type traits with C++14 variable templates">
<meta property="og:url" content="http://baptiste-wicht.com/posts/2017/08/simplify-your-type-traits-with-c%2B%2B14-variable-templates.html">
<meta property="og:description" content="Often if you write templated code, you have to write and use a lot of different
traits. In this article, I'll focus on the traits that are representing values,
typically a boolean value. For instance,">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-08-22T14:45:11+02:00">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++14">
<meta property="article:tag" content="Compilers">
<meta property="article:tag" content="etl">
<meta property="article:tag" content="projects">
<link href="../../../favicon.ico" rel="icon" type="image/x-icon">
<link rel="publisher" href="https://plus.google.com/+BaptisteWicht">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2175227-7', 'auto');
  var metas = document.getElementsByTagName('meta'), tagsList = [];
  for (var i=0; i<metas.length; i++) {
    if (metas[i].getAttribute('property') == 'article:tag') {
      tagsList.push( metas[i].getAttribute('content'));
    }
  }
  ga('set', 'dimension1', tagsList.join('|'));
  ga('send', 'pageview');
</script>
</head>
<body>

<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
<div class="container-fluid">

<div class="row">
<div class="col-sm-3 col-lg-2">
<nav class="navbar navbar-inverse navbar-fixed-side"><div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="http://baptiste-wicht.com/">
<span id="blog-title">Blog blog("Baptiste Wicht");</span>
</a>
</div>

<div class="collapse navbar-collapse navbar-ex1-collapse">
<ul class="nav navbar-nav">
<li>
<a href="../../../stories/about.html">About</a>
</li>
<li>
<a href="../../../stories/publications.html">Publications</a>
</li>
<li>
<a href="../../../stories/projects.html">Projects</a>
</li>
<li>
<a href="../../../categories/index.html">Tags</a>
</li>
<li>
<a href="../../../archive.html">Archives</a>
</li>
<li>
<a href="http://feeds.feedburner.com/BaptisteWicht">RSS</a>
</li>
<li class="navbar-content">
<h3>Related posts</h3>
</li>
<li><a href="../../2015/03/named-optional-template-parameters-compile-time.html">Named Optional Template parameters to configure a class at compile-time</a></li>
<li><a href="../../2015/07/simulate-static_if-with-c11c14.html">Simulate static_if with C++11/C++14</a></li>
<li><a href="../../2014/07/compile-integer-square-roots-at-compile-time-in-cpp.html">Compile integer Square Roots at compile-time in C++</a></li>
<li><a href="../../2011/11/cpp-templates-complete-guide-book.html">C++ Templates : The Complete Guide - Book Review</a></li>
<li><a href="../../2016/01/improve-dll-and-etl-compile-time-further.html">Improve DLL and ETL Compile Time further</a></li>
<li><a href="../../2016/02/use-templight-and-templar-to-debug-cpp-templates.html">Use templight and Templar to debug C++ templates</a></li>
<li class="navbar-block">
<li class="wicht-navbar-right">
<a target="_blank" title="Follow @wichtounet on Twitter" href="https://twitter.com/wichtounet">
<img src="../../../assets/img/twitter.png" alt="Follow @wichtounet on Twitter"></a>
</li>
<li class="wicht-navbar-right">
<a target="_blank" title="Follow +BaptisteWicht on Google+" href="https://plus.google.com/+BaptisteWicht">
<img src="../../../assets/img/google_plus.png" alt="Follow +BaptisteWicht on Google+"></a>
</li>
</ul>
</div>

</nav>
</div> 
<div class="col-sm-9 col-lg-10">
<div id="content"></div>
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="simplify-your-type-traits-with-c%2B%2B14-variable-templates.html" class="u-url">Simplify your type traits with C++14 variable templates</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">
Baptiste Wicht
</span></p>
<p class="dateline"><a href="simplify-your-type-traits-with-c%2B%2B14-variable-templates.html" rel="bookmark"><time class="published dt-published" datetime="2017-08-22T14:45:11+02:00" itemprop="datePublished" title="2017-08-22 14:45">2017-08-22 14:45</time></a></p>
<p class="commentline">
<a href="simplify-your-type-traits-with-c%2B%2B14-variable-templates.html#disqus_thread" data-disqus-identifier="cache/posts/2017/08/simplify-your-type-traits-with-c++14-variable-templates.html">Comments</a>
</p>
<p class="sourceline"><a href="simplify-your-type-traits-with-c%2B%2B14-variable-templates.rst" class="sourcelink">Source</a></p>
</div>
</header><div class="e-content entry-content" itemprop="articleBody text">
<div>
<p>Often if you write templated code, you have to write and use a lot of different
traits. In this article, I'll focus on the traits that are representing values,
typically a boolean value. For instance, std::is_const, std::is_same or
std::is_reference are type traits provided by the STL. They are giving you some
information at compile time for a certain type. If you need to write a type
traits, let's say is_float, here is how you would maybe do it in C++11:</p>
<pre class="code c++"><a name="rest_code_45b11d66ae264c94b9aa702fd745c672-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_45b11d66ae264c94b9aa702fd745c672-2"></a><span class="k">struct</span> <span class="n">is_float</span> <span class="p">{</span>
<a name="rest_code_45b11d66ae264c94b9aa702fd745c672-3"></a>    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<a name="rest_code_45b11d66ae264c94b9aa702fd745c672-4"></a><span class="p">};</span>
</pre>
<p>or a bit nicer with a template type alias and std::integral constant:</p>
<pre class="code c++"><a name="rest_code_5b7514df48de41949d3cb2865dffa98c-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_5b7514df48de41949d3cb2865dffa98c-2"></a><span class="k">using</span> <span class="n">is_float</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">;</span>
</pre>
<p>or since is_same is itself a type traits, you can also directly alias it:</p>
<pre class="code c++"><a name="rest_code_38f6a207f06249eaa4e2e427d8e07c1a-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_38f6a207f06249eaa4e2e427d8e07c1a-2"></a><span class="k">using</span> <span class="n">is_float</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">;</span>
</pre>
<p>This makes for some very nice syntax, but we still have a type rather than a value.</p>
<p>Note that in some cases, you cannot use the using technique since it cannot be
specialized and you often need specialization to write some more advanced
traits.</p>
<p>And then you would use your traits to do something specific based on that
information. For instance with a very basic example:</p>
<pre class="code C++"><a name="rest_code_06a0f8637289401b880e671fcd672628-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-2"></a><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-3"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">is_float</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">){</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-4"></a>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm a float"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-5"></a>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-6"></a>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm not a float"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-7"></a>    <span class="p">}</span>
<a name="rest_code_06a0f8637289401b880e671fcd672628-8"></a><span class="p">}</span>
</pre>
<p>Really nothing fancy here, but that will be enough as examples.</p>
<p>Even though all this works pretty, it can be made better on two points. First,
every time you use a traits, you need to use the value member (via ::value).
Secondly, every time you declare a new traits, you have to declare a new type or
a type alias. But all you want is a boolean value.</p>
<p>C++14 introduced a new feature, variable templates. As their name indicates,
they are variables, parametrized with a type. This allows us to write type
traits without using a type alias or struct, meaning we have a real value
instead of a type. If we rewrite our is_float traits with variable templates, we
have the following:</p>
<pre class="code c++"><a name="rest_code_794ce898460249cf8128e8f03cdbabf0-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_794ce898460249cf8128e8f03cdbabf0-2"></a><span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_float</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
</pre>
<p>I think it's much nicer, the intent is clearly stated and there is no
unnecessary code. Moreover, it's also nicer to use:</p>
<pre class="code C++"><a name="rest_code_4a69bf93945e4964a57a9536d106353a-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-2"></a><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-3"></a>    <span class="k">if</span> <span class="p">(</span><span class="n">is_float</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">){</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-4"></a>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm a float"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-5"></a>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-6"></a>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm not a float"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-7"></a>    <span class="p">}</span>
<a name="rest_code_4a69bf93945e4964a57a9536d106353a-8"></a><span class="p">}</span>
</pre>
<p>No more ::value everywhere :) I think it's really cool.</p>
<p>Note that, unlike type alias template, they can be specialized, either fully or
partially, so no more limitation on that side.</p>
<p>Interestingly, variable templates are used in C++17 to provide helpers for each
type traits with values. For instance, std::is_same will have a std::is_same_v
helper that is a variable template. With that, we can simplify our traits a bit
more:</p>
<pre class="code c++"><a name="rest_code_32ed21ff43bc4b289e77ba2279eabc04-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_32ed21ff43bc4b289e77ba2279eabc04-2"></a><span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_float</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">;</span>
</pre>
<p>Personally, I replaced all the type traits inside ETL using variable templates.
If you don't want to do it, you can also introduce helpers like in the C++17 STL
and start using the wrappers when you see fit so that you don't break any code.</p>
<p>If you want to use this feature, you need a C++14 compiler, such as any version
from GCC5 family or clang 3.6. Although I haven't tested, it should also work on
Microsoft VS2015 Update 2.</p>
<p>Unfortunately there is a bug in both clang (fixed in clang 3.7) and GCC (fixed
in GCC 6 only) that you may encounter if you start using variable templates in
template classes or variable templates used in another variable templates. If
you plan to use variable templates inside a template, such as something like
this:</p>
<pre class="code c++"><a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-1"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-2"></a><span class="k">struct</span> <span class="n">outer_traits</span> <span class="p">{</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-3"></a>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-4"></a>    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">sub_traits</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-5"></a><span class="p">};</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-6"></a>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-7"></a><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-8"></a><span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">outer_helper</span> <span class="o">=</span> <span class="n">outer_traits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">template</span> <span class="n">sub_traits</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-9"></a>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-10"></a><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-11"></a>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">outer_helper</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-12"></a>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-13"></a>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<a name="rest_code_cadac6599e3749ee8bbb1105d0bb7ef0-14"></a><span class="p">}</span>
</pre>
<p>You will encounter a not-helpful at all error message with GCC5 family, such as:</p>
<pre class="code text"><a name="rest_code_d50ed49e99294025a1490dc4f343eac5-1"></a>test.cpp: In instantiation of ‘constexpr const bool outer_helper&lt;float, float&gt;’:
<a name="rest_code_d50ed49e99294025a1490dc4f343eac5-2"></a>test.cpp:14:22:   required from here
<a name="rest_code_d50ed49e99294025a1490dc4f343eac5-3"></a>test.cpp:11:20: error: ‘template&lt;class X&gt; constexpr const bool outer_traits&lt;float&gt;::sub_traits&lt;X&gt;’ is not a function template
<a name="rest_code_d50ed49e99294025a1490dc4f343eac5-4"></a>     constexpr bool outer_helper = outer_traits&lt;T&gt;::template sub_trait
<a name="rest_code_d50ed49e99294025a1490dc4f343eac5-5"></a>                    ^
<a name="rest_code_d50ed49e99294025a1490dc4f343eac5-6"></a>test.cpp:11:20: error: ‘sub_traits&lt;X&gt;’ is not a member of ‘outer_traits&lt;float&gt;’
</pre>
<p>It comes from a bug in the handling of variable templates as dependent names. If
you don't come in this cases, you can use GCC5 family directly, otherwise,
you'll have to use GCC6 family only.</p>
<p>I hope this can help some of you to improve your type traits or at least to
discover the power of the new variable templates. Personally, I've rewritten all
the traits from the ETL library using this new feature and I'm pretty satisfied
with the result. Of course, that means that the compiler support was reduced,
but since I don't have many users, it's not a real issue.</p>
</div>
</div>
<aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/c%2B%2B.html" rel="tag">C++</a></li>
<li><a class="tag p-category" href="../../../categories/c%2B%2B14.html" rel="tag">C++14</a></li>
<li><a class="tag p-category" href="../../../categories/compilers.html" rel="tag">Compilers</a></li>
<li><a class="tag p-category" href="../../../categories/etl.html" rel="tag">etl</a></li>
<li><a class="tag p-category" href="../../../categories/projects.html" rel="tag">projects</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous">
<a href="how-to-fix-mdadm-raid5-raid6-growing-stuck-at-0ks.html" rel="prev" title="How to fix mdadm RAID5 / RAID6 growing stuck at 0K/s ?">Previous post</a>
</li>
<li class="next">
<a href="../09/cpp11-concurrency-tutorial-futures.html" rel="next" title="C++11 Concurrency Tutorial - Part 5: Futures">Next post</a>
</li>
</ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
<div id="disqus_thread"></div>
<script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2017/08/simplify-your-type-traits-with-c%2B%2B14-variable-templates.html",
        disqus_title="Simplify your type traits with C++14 variable templates",
        disqus_identifier="cache/posts/2017/08/simplify-your-type-traits-with-c++14-variable-templates.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>
</section></article><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div> 
</div>

</div>



<footer>
Contents © 2017 <a href="/cdn-cgi/l/email-protection#6c0e0d1c18051f18091b050f04182c0b010d0500420f0301">Baptiste Wicht</a> - Powered by <a href="http://getnikola.com" rel="nofollow">Nikola</a> - License:
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="../../../assets/img/cc.png"></a>
<ul class="footer_inline_ul">
<li>
<a href="simplify-your-type-traits-with-c%2B%2B14-variable-templates.rst" id="sourcelink">Source</a>
</li>
</ul></footer><script src="/cdn-cgi/scripts/78d64697/cloudflare-static/email-decode.min.js"></script><script src="../../../assets/js/all-nocdn.js"></script>
</body>
</html>
