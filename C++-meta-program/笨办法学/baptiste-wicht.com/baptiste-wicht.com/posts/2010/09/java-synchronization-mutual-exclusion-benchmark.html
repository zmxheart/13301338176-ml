<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Java Synchronization (Mutual Exclusion) Benchmark | Blog blog("Baptiste Wicht");</title>
<script src="/cdn-cgi/apps/head/98vpnawSZZMscPn4oDND-ZgswjM.js"></script><link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="http://baptiste-wicht.com/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Baptiste Wicht">
<link rel="prev" href="../08/java-concurrency-part-4-semaphores.html" title="Java Concurrency - Part 4 : Semaphores" type="text/html">
<link rel="next" href="my-java-benchmarks-on-github.html" title="My Java Benchmarks on GitHub" type="text/html">
<meta property="og:site_name" content='Blog blog("Baptiste Wicht");'>
<meta property="og:title" content="Java Synchronization (Mutual Exclusion) Benchmark">
<meta property="og:url" content="http://baptiste-wicht.com/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html">
<meta property="og:description" content="I've created another benchmark. This time, I've benchmarked the different ways of synchronizing a little code using mutual exclusion on this code.
The code to protect will be very simple. It's a simpl">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2010-09-01T07:13:18+02:00">
<meta property="article:tag" content="Benchmarks">
<meta property="article:tag" content="Concurrency">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Performances">
<link href="../../../favicon.ico" rel="icon" type="image/x-icon">
<link rel="publisher" href="https://plus.google.com/+BaptisteWicht">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2175227-7', 'auto');
  var metas = document.getElementsByTagName('meta'), tagsList = [];
  for (var i=0; i<metas.length; i++) {
    if (metas[i].getAttribute('property') == 'article:tag') {
      tagsList.push( metas[i].getAttribute('content'));
    }
  }
  ga('set', 'dimension1', tagsList.join('|'));
  ga('send', 'pageview');
</script>
</head>
<body>

<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
<div class="container-fluid">

<div class="row">
<div class="col-sm-3 col-lg-2">
<nav class="navbar navbar-inverse navbar-fixed-side"><div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="http://baptiste-wicht.com/">
<span id="blog-title">Blog blog("Baptiste Wicht");</span>
</a>
</div>

<div class="collapse navbar-collapse navbar-ex1-collapse">
<ul class="nav navbar-nav">
<li>
<a href="../../../stories/about.html">About</a>
</li>
<li>
<a href="../../../stories/publications.html">Publications</a>
</li>
<li>
<a href="../../../stories/projects.html">Projects</a>
</li>
<li>
<a href="../../../categories/index.html">Tags</a>
</li>
<li>
<a href="../../../archive.html">Archives</a>
</li>
<li>
<a href="http://feeds.feedburner.com/BaptisteWicht">RSS</a>
</li>
<li class="navbar-content">
<h3>Related posts</h3>
</li>
<li><a href="../08/java-concurrrency-synchronization-locks.html">Java Concurrency – Part 3 : Synchronization with intrinsic locks</a></li>
<li><a href="java-concurrency-part-5-monitors-locks-and-conditions.html">Java Concurrency - Part 5 : Monitors (Locks and Conditions)</a></li>
<li><a href="../08/java-concurrency-part-4-semaphores.html">Java Concurrency - Part 4 : Semaphores</a></li>
<li><a href="my-java-benchmarks-on-github.html">My Java Benchmarks on GitHub</a></li>
<li><a href="../../2012/07/c11-synchronization-benchmark.html">C++11 Synchronization Benchmark</a></li>
<li><a href="java-concurrency-atomic-variables.html">Java Concurrency - Part 6 : Atomic Variables</a></li>
<li class="navbar-block">
<li class="wicht-navbar-right">
<a target="_blank" title="Follow @wichtounet on Twitter" href="https://twitter.com/wichtounet">
<img src="../../../assets/img/twitter.png" alt="Follow @wichtounet on Twitter"></a>
</li>
<li class="wicht-navbar-right">
<a target="_blank" title="Follow +BaptisteWicht on Google+" href="https://plus.google.com/+BaptisteWicht">
<img src="../../../assets/img/google_plus.png" alt="Follow +BaptisteWicht on Google+"></a>
</li>
</ul>
</div>

</nav>
</div> 
<div class="col-sm-9 col-lg-10">
<div id="content"></div>
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Java Synchronization (Mutual Exclusion) Benchmark</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">
Baptiste Wicht
</span></p>
<p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2010-09-01T07:13:18+02:00" itemprop="datePublished" title="2010-09-01 07:13">2010-09-01 07:13</time></a></p>
<p class="commentline">
<a href="java-synchronization-mutual-exclusion-benchmark.html#disqus_thread" data-disqus-identifier="cache/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html">Comments</a>
</p>
<p class="sourceline"><a href="java-synchronization-mutual-exclusion-benchmark.wp" class="sourcelink">Source</a></p>
</div>
</header><div class="e-content entry-content" itemprop="articleBody text">
<div>
<p>I've created another benchmark. This time, I've benchmarked the different ways of synchronizing a little code using <strong>mutual exclusion</strong> on this code.</p>
<p>The code to protect will be very simple. It's a simple counter :</p>
<pre class="code literal-block"><span></span><span class="c1">//Init</span>
<span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> 
<span class="c1">//Critical section</span>
<span class="n">counter</span><span class="o">++;</span>
</pre>
<p>The critical section, if not protected with synchronization system, will not function properly due to possible <strong>interleavings</strong> (read <a href="http://www.baptiste-wicht.com/2010/08/java-concurrrency-synchronization-locks/" target="_blank">the article on synchronization</a> if you don't know what is <strong>interleaving</strong>).</p>

<p>I've used 3 different synchronizers to synchronize this increment :</p>
<ol>
<li>synchronized block</li>
<li>Semaphores (fair and unfair)</li>
<li>Explicit locks (fair and unfair)</li>
</ol>
<p>I've also used a third way to solve the problem with AtomicInteger. This is not the same as the other ways because it does not provide mutual exclusion but this is a good way to synchronize simple values, like integers or boolean, but also references. The atomicity of the operations of the AtomicInteger is made using the compare-and-swap operation of the operating system. So there is no waiting operations. So there is less context switches and result in more performing code normally.</p>
<p>Here is the code of these 4 ways to solve the problems :</p>
<pre class="code literal-block"><span></span><span class="kd">private</span> <span class="kd">class</span> <span class="nc">SynchronizedRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">counter</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">class</span> <span class="nc">ReentrantLockRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Lock</span> <span class="n">lock</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">ReentrantLockRunnable</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>

        <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">(</span><span class="n">fair</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">counter</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">class</span> <span class="nc">SemaphoreRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Semaphore</span> <span class="n">semaphore</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">SemaphoreRunnable</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>

        <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">fair</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">counter</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">class</span> <span class="nc">AtomicIntegerRunnable</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">AtomicInteger</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">counter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
<p>I used Runnable to facilitate the testing and timing of the different mechanisms.</p>
<p>The test is made in two phases :</p>
<ol>
<li>Test with only one thread with a sophisticated benchmark framework. This act also as warmup for the different code.</li>
<li>Test with several threads (several test with increasing number of threads). The test is made using a little code I wrote for the occasion. Each method is executed 2²³ times (8388608 times exactly).</li>
</ol>
<p>The source code is available at the end of the post.</p>
<p>The test has been launched on a Ubuntu 10.04 with a Java 6 virtual machine. The computer has a 64 bit Core 2 Duo 3.16 Ghz processor and 6Go of DDR2.</p>
<p>So let's see the results. First with one thread :</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-benchmark.png"><img class="size-full wp-image-999" title="Synchronization Benchmark - One Thread" src="../../../wp-content/uploads/2010/08/Synchronization-benchmark.png" alt="Synchronization Benchmark - One Thread" width="500" height="400"></a></p>
<p>The first thing we see is that the AtomicInteger is the fastest version. This is because AtomicInteger do not use waiting operation, so this result in less context switches and more performances. But this is not exactly the case of the benchmark, so let's concentrate on the 5 others methods. We see that the synchronized method is the fastest and that fair methods are a little slower than unfair, but not a lot.</p>
<p>Now, we'll test the scalability of all these methods using several threads.</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-2-threads.png"><img class="size-full wp-image-1000" title="Synchronization - 2 threads" src="../../../wp-content/uploads/2010/08/Synchronization-2-threads.png" alt="Synchronization - 2 threads" width="500" height="400"></a></p>
<p>This method we can see that the fair methods are awfully slow compared to the the unfair versions. Indeed adding fairness to a synchronizer is really heavy. When fair, the threads acquire the locks in the order they ask for. With nonfair locks, barging is allowed. So when a thread try to acquire the lock and its available, it can acquire it even if there is threads waiing for the lock. It's heavier to provide fairness because there is a lot more context switches. The problem was not here with only one thread because it's always fair.</p>
<p>The results for the other versions are the same as with one thread.</p>
<p>Let's add two more threads :</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-4-threads.png"><img class="size-full wp-image-1001" title="Synchronization - 4 threads" src="../../../wp-content/uploads/2010/08/Synchronization-4-threads.png" alt="Synchronization - 4 threads" width="500" height="400"></a></p>
<p>The fair versions are more and more slows when we add threads. The scalability of these methods is really bad. Let's see the graph without the fair versions :</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-4-threads-sub.png"><img class="size-full wp-image-1002" title="Synchronization - 4 threads" src="../../../wp-content/uploads/2010/08/Synchronization-4-threads-sub.png" alt="Synchronization - 4 threads" width="500" height="400"></a></p>
<p>This time we can see some differences. The synchronized method is the slower this time and semaphore has a little advantage. Let's see with 8 threads :</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-8-threads.png"><img class="size-full wp-image-1003" title="Synchronization - 8 threads" src="../../../wp-content/uploads/2010/08/Synchronization-8-threads.png" alt="Synchronization - 8 threads" width="500" height="400"></a></p>
<p>Here the synchronized method is really slower than the other methods. It appears that the algorithm of the synchronized block is less scalable than the explicit locks and semaphore versions. Let's watch what happens with other number of threads :</p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-32-threads.png"><img class="size-full wp-image-1004" title="Synchronization - 32 threads" src="../../../wp-content/uploads/2010/08/Synchronization-32-threads.png" alt="Synchronization - 32 threads" width="500" height="400"></a></p>
<p><a href="../../../wp-content/uploads/2010/08/Synchronization-128-threads.png"><img class="size-full wp-image-1005" title="Synchronization - 128 threads" src="../../../wp-content/uploads/2010/08/Synchronization-128-threads.png" alt="Synchronization - 128 threads" width="500" height="400"></a></p>
<p>I've also made the test with other number of threads (16, 64 and 256), but the results are the same as the other.</p>
<p>We can made several conclusions based on the results :</p>
<ol>
<li>Fair versions are slow. If you don't absolutely need fairness, don't use fair locks or semaphores</li>
<li>Semaphores and explicit locks have the same performances. This is because the 2 classes (Semaphore and ReentrantLock) are based on the same class AbstractQueueSynchronizer that is used by almost all synchronization mechanisms of Java</li>
<li>Explicit locks and semaphores are more scalable than synchronized blocks. But that depend on the virtual machine, I've seen other results indicating that the difference is a lot smaller</li>
<li>The AtomicInteger is the most performing method. This class doesn't provide mutual exclusion, but provide thread safe methods to works on simple values (there is version for Long, Double, Boolean and even Reference)</li>
</ol>
<p>So that's all for this benchmark. I hope you found it interesting.</p>
<p>The sources of the benchmark : <a href="../../../wp-content/uploads/2010/08/SynchronizationBenchmark.java">Synchronization Benchmark Sources</a></p>
</div>
</div>
<aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/benchmarks.html" rel="tag">Benchmarks</a></li>
<li><a class="tag p-category" href="../../../categories/concurrency.html" rel="tag">Concurrency</a></li>
<li><a class="tag p-category" href="../../../categories/java.html" rel="tag">Java</a></li>
<li><a class="tag p-category" href="../../../categories/performances.html" rel="tag">Performances</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous">
<a href="../08/java-concurrency-part-4-semaphores.html" rel="prev" title="Java Concurrency - Part 4 : Semaphores">Previous post</a>
</li>
<li class="next">
<a href="my-java-benchmarks-on-github.html" rel="next" title="My Java Benchmarks on GitHub">Next post</a>
</li>
</ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
<div id="disqus_thread"></div>
<script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html",
        disqus_title="Java Synchronization (Mutual Exclusion) Benchmark",
        disqus_identifier="cache/posts/2010/09/java-synchronization-mutual-exclusion-benchmark.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>
</section></article><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div> 
</div>

</div>



<footer>
Contents © 2017 <a href="/cdn-cgi/l/email-protection#4c2e2d3c38253f38293b252f24380c2b212d2520622f2321">Baptiste Wicht</a> - Powered by <a href="http://getnikola.com" rel="nofollow">Nikola</a> - License:
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="../../../assets/img/cc.png"></a>
<ul class="footer_inline_ul">
<li>
<a href="java-synchronization-mutual-exclusion-benchmark.wp" id="sourcelink">Source</a>
</li>
</ul></footer><script src="/cdn-cgi/scripts/78d64697/cloudflare-static/email-decode.min.js"></script><script src="../../../assets/js/all-nocdn.js"></script>
</body>
</html>
