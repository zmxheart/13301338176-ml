<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Memory Manager in 64bits Intel Assembly on Linux | Blog blog("Baptiste Wicht");</title>
<script src="/cdn-cgi/apps/head/98vpnawSZZMscPn4oDND-ZgswjM.js"></script><link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Baptiste Wicht">
<link rel="prev" href="../07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html" title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors" type="text/html">
<link rel="next" href="architexa-free-understand-code-base.html" title="Architexa is available for free - Understand your code base" type="text/html">
<meta property="og:site_name" content='Blog blog("Baptiste Wicht");'>
<meta property="og:title" content="Memory Manager in 64bits Intel Assembly on Linux">
<meta property="og:url" content="http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html">
<meta property="og:description" content="For the last version of the EDDI Compiler, it has been necessary to extend the dynamic memory allocator, to support free memory. In this post, we will see how to write a simple Memory Manager in Intel">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2012-08-02T08:05:30+02:00">
<meta property="article:tag" content="Assembly">
<meta property="article:tag" content="Intel">
<meta property="article:tag" content="Linux">
<link href="../../../favicon.ico" rel="icon" type="image/x-icon">
<link rel="publisher" href="https://plus.google.com/+BaptisteWicht">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2175227-7', 'auto');
  var metas = document.getElementsByTagName('meta'), tagsList = [];
  for (var i=0; i<metas.length; i++) {
    if (metas[i].getAttribute('property') == 'article:tag') {
      tagsList.push( metas[i].getAttribute('content'));
    }
  }
  ga('set', 'dimension1', tagsList.join('|'));
  ga('send', 'pageview');
</script>
</head>
<body>

<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
<div class="container-fluid">

<div class="row">
<div class="col-sm-3 col-lg-2">
<nav class="navbar navbar-inverse navbar-fixed-side"><div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="http://baptiste-wicht.com/">
<span id="blog-title">Blog blog("Baptiste Wicht");</span>
</a>
</div>

<div class="collapse navbar-collapse navbar-ex1-collapse">
<ul class="nav navbar-nav">
<li>
<a href="../../../stories/about.html">About</a>
</li>
<li>
<a href="../../../stories/publications.html">Publications</a>
</li>
<li>
<a href="../../../stories/projects.html">Projects</a>
</li>
<li>
<a href="../../../categories/index.html">Tags</a>
</li>
<li>
<a href="../../../archive.html">Archives</a>
</li>
<li>
<a href="http://feeds.feedburner.com/BaptisteWicht">RSS</a>
</li>
<li class="navbar-content">
<h3>Related posts</h3>
</li>
<li><a href="../../2011/11/dynamic-memory-allocation-intel-assembly-linux.html">Dynamic memory allocation in Intel Assembly on Linux</a></li>
<li><a href="../07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html">EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors</a></li>
<li><a href="../03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html">Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</a></li>
<li><a href="../../2011/11/print-strings-integers-intel-assembly.html">How to print strings and integers in Intel Assembly on Linux ?</a></li>
<li><a href="../../2011/11/eddic-0-5-1-better-assembly-generation-and-faster-parsing.html">eddic 0.5.1 : Better assembly generation and faster parsing</a></li>
<li><a href="../../2010/02/java-keywords.html">The reserved keywords of the Java Language</a></li>
<li class="navbar-block">
<li class="wicht-navbar-right">
<a target="_blank" title="Follow @wichtounet on Twitter" href="https://twitter.com/wichtounet">
<img src="../../../assets/img/twitter.png" alt="Follow @wichtounet on Twitter"></a>
</li>
<li class="wicht-navbar-right">
<a target="_blank" title="Follow +BaptisteWicht on Google+" href="https://plus.google.com/+BaptisteWicht">
<img src="../../../assets/img/google_plus.png" alt="Follow +BaptisteWicht on Google+"></a>
</li>
</ul>
</div>

</nav>
</div> 
<div class="col-sm-9 col-lg-10">
<div id="content"></div>
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Memory Manager in 64bits Intel Assembly on Linux</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">
Baptiste Wicht
</span></p>
<p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2012-08-02T08:05:30+02:00" itemprop="datePublished" title="2012-08-02 08:05">2012-08-02 08:05</time></a></p>
<p class="commentline">
<a href="memory-manager-intel-assembly-64-linux.html#disqus_thread" data-disqus-identifier="cache/posts/2012/08/memory-manager-intel-assembly-64-linux.html">Comments</a>
</p>
<p class="sourceline"><a href="memory-manager-intel-assembly-64-linux.wp" class="sourcelink">Source</a></p>
</div>
</header><div class="e-content entry-content" itemprop="articleBody text">
<div>
<p>For <a title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors" href="http://www.baptiste-wicht.com/2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors/">the last version of the EDDI Compiler</a>, it has been necessary to extend the dynamic memory allocator, to support free memory. In this post, we will see how to write a simple Memory Manager in Intel Assembly for Linux.</p>
<p>In the past, we've seen <a title="Dynamic memory allocation in Intel Assembly on Linux" href="http://www.baptiste-wicht.com/2011/11/dynamic-memory-allocation-intel-assembly-linux/">how to write a basic memory allocator</a>, this time, we will write a more complete version.</p>
<p>The implementation is made in 64bits Intel Assembly.</p>
<h4>Memory Manager specification</h4>
<p>The memory will be allocated by blocks. Each block will contain a header with two information:</p>
<ul>
<li>A boolean flag indicating if the block is free or not</li>
<li>The size of the block (including the header)</li>
</ul>
<p>Each time some memory is asked, the blocks are tested one by one until an available one is found. If no available block is found, a new block is allocated after the last one and this block is returned.</p>
<p>The memory manager consists of three functions:</p>
<ul>
<li>memory_init: Init the memory manager</li>
<li>memory_alloc: Allocate the given number of bytes of memory</li>
<li>memory_free: Release the given block</li>
</ul>
<p>The parameter is passed in the <strong>r14</strong> register. The return value is returned in the <strong>rax</strong> register.</p>
<h4>Global State</h4>
<p>This implementation needs two global variables. One for the start address of memory and the other one for the last:</p>
<pre class="code literal-block"><span></span><span class="k">section</span> <span class="nv">.data</span>
<span class="nf">mem_last</span> <span class="nv">dq</span> <span class="mi">0</span>
<span class="nf">mem_start</span> <span class="nv">dq</span> <span class="mi">0</span>
</pre>
<h4>Init memory Manager</h4>
<p>The init function is very simple to implement:</p>
<pre class="code literal-block"><span></span><span class="nl">init:</span>
<span class="nf">push</span> <span class="nb">rbp</span>
<span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">12</span>
<span class="nf">xor</span> <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rdi</span>
<span class="nf">syscall</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nv">mem_start</span><span class="p">],</span> <span class="nb">rax</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nv">mem_last</span><span class="p">],</span> <span class="nb">rax</span>
<span class="nf">leave</span>
<span class="nf">ret</span>
</pre>
<p>We just have to call sys_brk in order to get the location of <em>program break</em>. Then, the start and the last addresses are the same.</p>
<h4>Free memory</h4>
<p>The free function is the simplest one:</p>
<pre class="code literal-block"><span></span><span class="nl">free:</span>
<span class="nf">push</span> <span class="nb">rbp</span>
<span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r14</span> <span class="o">-</span> <span class="mi">16</span><span class="p">],</span> <span class="mi">1</span>
<span class="nf">leave</span>
<span class="nf">ret</span>
</pre>
<p>The address to free is passed in the <strong>r14</strong> register. We have to go back 16 bytes (size of the control block) to go to the start of the block. The availability flag is set to 1 (the block is free).</p>
<h4>The alloc function</h4>
<p>The alloc function is the most complex:</p>
<pre class="code literal-block"><span></span><span class="nl">alloc:</span>
<span class="nf">push</span> <span class="nb">rbp</span>
<span class="nf">mov</span> <span class="nb">rbp</span><span class="p">,</span> <span class="nb">rsp</span>
<span class="nf">push</span> <span class="nb">rdi</span>
<span class="nf">push</span> <span class="nv">r10</span>
<span class="nf">push</span> <span class="nv">r11</span>
<span class="nf">push</span> <span class="nv">r12</span>
<span class="nf">push</span> <span class="nv">r13</span>
<span class="nf">push</span> <span class="nv">r14</span>
<span class="nf">add</span> <span class="nv">r14</span><span class="p">,</span> <span class="mi">16</span>
<span class="nf">mov</span> <span class="nv">r12</span><span class="p">,</span> <span class="p">[</span><span class="nv">mem_start</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nv">r13</span><span class="p">,</span> <span class="p">[</span><span class="nv">mem_last</span><span class="p">]</span>
<span class="nl">.start:</span>
<span class="nf">cmp</span> <span class="nv">r12</span><span class="p">,</span> <span class="nv">r13</span>
<span class="nf">je</span> <span class="nv">.alloc</span>
<span class="nf">mov</span> <span class="nv">r10</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nv">r11</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="nf">cmp</span> <span class="nv">r10</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">jne</span> <span class="nv">.move</span>
<span class="nf">cmp</span> <span class="nv">r11</span><span class="p">,</span> <span class="nv">r14</span>
<span class="nf">jl</span> <span class="nv">.move</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="nf">pop</span> <span class="nv">r14</span>
<span class="nf">pop</span> <span class="nv">r13</span>
<span class="nf">pop</span> <span class="nv">r12</span>
<span class="nf">pop</span> <span class="nv">r11</span>
<span class="nf">pop</span> <span class="nv">r10</span>
<span class="nf">pop</span> <span class="nb">rdi</span>
<span class="nf">leave</span>
<span class="nf">ret</span>

<span class="nl">.move:</span>
<span class="nf">add</span> <span class="nv">r12</span><span class="p">,</span> <span class="nv">r11</span>
<span class="nf">jmp</span> <span class="nv">.start</span>

<span class="nl">.alloc:</span>
<span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="nv">r14</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">12</span>
<span class="nf">syscall</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nv">mem_last</span><span class="p">],</span> <span class="nb">rdi</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="nv">r14</span>
<span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
<span class="nf">pop</span> <span class="nv">r14</span>
<span class="nf">pop</span> <span class="nv">r13</span>
<span class="nf">pop</span> <span class="nv">r12</span>
<span class="nf">pop</span> <span class="nv">r11</span>
<span class="nf">pop</span> <span class="nv">r10</span>
<span class="nf">pop</span> <span class="nb">rdi</span>
<span class="nf">leave</span>
<span class="nf">ret</span>
</pre>
<p>As the function is a bit complex, I will detail it in part:</p>
<pre class="code literal-block"><span></span><span class="nf">add</span> <span class="nv">r14</span><span class="p">,</span> <span class="mi">16</span>
<span class="nf">mov</span> <span class="nv">r12</span><span class="p">,</span> <span class="p">[</span><span class="nv">mem_start</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nv">r13</span><span class="p">,</span> <span class="p">[</span><span class="nv">mem_last</span><span class="p">]</span>
<span class="nl">.start:</span>
<span class="nf">cmp</span> <span class="nv">r12</span><span class="p">,</span> <span class="nv">r13</span>
<span class="nf">je</span> <span class="nv">.alloc</span>
<span class="nf">mov</span> <span class="nv">r10</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nv">r11</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">]</span>
<span class="nf">cmp</span> <span class="nv">r10</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">jne</span> <span class="nv">.move</span>
<span class="nf">cmp</span> <span class="nv">r11</span><span class="p">,</span> <span class="nv">r14</span>
<span class="nf">jl</span> <span class="nv">.move</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
</pre>
<p>The necessary number of bytes is passed in the <strong>r14</strong> register. We add 16 bytes (size of the control group) to the size as we also need some place for the header. Then, we load the start and last addresses. If both addresses are equal, we need to allocate more memory (detailed later). Then, we check the size and the availability of the current block. If the size is enough to fit the needs and the block is available, we set it to unavailable. We return the address past the control block (16 bytes).</p>
<pre class="code literal-block"><span></span><span class="nl">.move:</span>
<span class="nf">add</span> <span class="nv">r12</span><span class="p">,</span> <span class="nv">r11</span>
<span class="nf">jmp</span> <span class="nv">.start</span>
</pre>
<p>To move to the next block, we just have to add the size of the current block to the current block address.</p>
<pre class="code literal-block"><span></span><span class="nl">.alloc:</span>
<span class="nf">lea</span> <span class="nb">rdi</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="nv">r14</span><span class="p">]</span>
<span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="mi">12</span>
<span class="nf">syscall</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nv">V_mem_last</span><span class="p">],</span> <span class="nb">rdi</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span><span class="p">],</span> <span class="mi">0</span>
<span class="nf">mov</span> <span class="kt">qword</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="nv">r14</span>
<span class="nf">lea</span> <span class="nb">rax</span><span class="p">,</span> <span class="p">[</span><span class="nv">r12</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span>
</pre>
<p>To allocate memory, we compute the new <em>program break</em> and call <em>sys_brk</em> again to set the new <em>program break</em>. The block is then set to not available and the size is set. We return the address past the control block (16 bytes).</p>
<p>The rest of the program is just here to save and restore the registers and compute the stack frames.</p>
<h4>Wrap-Up</h4>
<p>In this article, we saw how to implement a very simple memory manager in 64bits Intel Assembly on Linux. This memory manager is very simple, but has several drawbacks:</p>
<ul>
<li>The overhead for small blocks is important. For example, allocating an 8 bytes integer needs a 24 bytes block, thrice the size of the int.</li>
<li>In the worst-case scenario, all of the process memory need to be walked across to find a new free block</li>
<li>The functions are not thread-safe</li>
<li>This algorithm can lead to a lot of memory fragmentation</li>
</ul>
<p>In the future I will try to make a more powerful version of this memory manager.</p>
<h4>Download</h4>
<p>All the functions are available online on the Github Repository:</p>
<ul>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_alloc.s">alloc</a></li>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_free.s">free</a></li>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_64_init.s">init</a></li>
</ul>
<p>They are also available in 32bits Intel Assembly:</p>
<ul>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_alloc.s">alloc</a></li>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_free.s">free</a></li>
<li><a href="https://github.com/wichtounet/eddic/blob/develop/functions/x86_32_init.s">init</a></li>
</ul>
</div>
</div>
<aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/assembly.html" rel="tag">Assembly</a></li>
<li><a class="tag p-category" href="../../../categories/intel.html" rel="tag">Intel</a></li>
<li><a class="tag p-category" href="../../../categories/linux.html" rel="tag">Linux</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous">
<a href="../07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html" rel="prev" title="EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors">Previous post</a>
</li>
<li class="next">
<a href="architexa-free-understand-code-base.html" rel="next" title="Architexa is available for free - Understand your code base">Next post</a>
</li>
</ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
<div id="disqus_thread"></div>
<script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2012/08/memory-manager-intel-assembly-64-linux.html",
        disqus_title="Memory Manager in 64bits Intel Assembly on Linux",
        disqus_identifier="cache/posts/2012/08/memory-manager-intel-assembly-64-linux.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>
</section></article><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div> 
</div>

</div>



<footer>
Contents © 2017 <a href="/cdn-cgi/l/email-protection#56343726223f252233213f353e2216313b373f3a7835393b">Baptiste Wicht</a> - Powered by <a href="http://getnikola.com" rel="nofollow">Nikola</a> - License:
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="../../../assets/img/cc.png"></a>
<ul class="footer_inline_ul">
<li>
<a href="memory-manager-intel-assembly-64-linux.wp" id="sourcelink">Source</a>
</li>
</ul></footer><script src="/cdn-cgi/scripts/78d64697/cloudflare-static/email-decode.min.js"></script><script src="../../../assets/js/all-nocdn.js"></script>
</body>
</html>
