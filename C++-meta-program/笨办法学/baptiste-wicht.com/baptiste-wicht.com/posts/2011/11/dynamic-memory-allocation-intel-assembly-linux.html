<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Dynamic memory allocation in Intel Assembly on Linux | Blog blog("Baptiste Wicht");</title>
<script src="/cdn-cgi/apps/head/98vpnawSZZMscPn4oDND-ZgswjM.js"></script><link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="http://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Baptiste Wicht">
<link rel="prev" href="eddi-compiler-0-6-1.html" title="EDDI Compiler 0.6.1 : Function return types" type="text/html">
<link rel="next" href="cpp-templates-complete-guide-book.html" title="C++ Templates : The Complete Guide - Book Review" type="text/html">
<meta property="og:site_name" content='Blog blog("Baptiste Wicht");'>
<meta property="og:title" content="Dynamic memory allocation in Intel Assembly on Linux">
<meta property="og:url" content="http://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html">
<meta property="og:description" content="For the version 0.6.0 of the EDDI Compiler, I have written a simple dynamic memory allocation function in assembly. I did that to avoid using malloc in my assembly code. As this is not an easy subject">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2011-11-29T09:16:26+01:00">
<meta property="article:tag" content="Assembly">
<meta property="article:tag" content="EDDI">
<meta property="article:tag" content="Intel">
<meta property="article:tag" content="Linux">
<link href="../../../favicon.ico" rel="icon" type="image/x-icon">
<link rel="publisher" href="https://plus.google.com/+BaptisteWicht">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-2175227-7', 'auto');
  var metas = document.getElementsByTagName('meta'), tagsList = [];
  for (var i=0; i<metas.length; i++) {
    if (metas[i].getAttribute('property') == 'article:tag') {
      tagsList.push( metas[i].getAttribute('content'));
    }
  }
  ga('set', 'dimension1', tagsList.join('|'));
  ga('send', 'pageview');
</script>
</head>
<body>

<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
<div class="container-fluid">

<div class="row">
<div class="col-sm-3 col-lg-2">
<nav class="navbar navbar-inverse navbar-fixed-side"><div class="navbar-header">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
<span class="sr-only">Toggle navigation</span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</button>
<a class="navbar-brand" href="http://baptiste-wicht.com/">
<span id="blog-title">Blog blog("Baptiste Wicht");</span>
</a>
</div>

<div class="collapse navbar-collapse navbar-ex1-collapse">
<ul class="nav navbar-nav">
<li>
<a href="../../../stories/about.html">About</a>
</li>
<li>
<a href="../../../stories/publications.html">Publications</a>
</li>
<li>
<a href="../../../stories/projects.html">Projects</a>
</li>
<li>
<a href="../../../categories/index.html">Tags</a>
</li>
<li>
<a href="../../../archive.html">Archives</a>
</li>
<li>
<a href="http://feeds.feedburner.com/BaptisteWicht">RSS</a>
</li>
<li class="navbar-content">
<h3>Related posts</h3>
</li>
<li><a href="../../2012/08/memory-manager-intel-assembly-64-linux.html">Memory Manager in 64bits Intel Assembly on Linux</a></li>
<li><a href="../../2012/07/eddi-compiler-1-1-1-dynamic-memory-allocation-constructors-destructors.html">EDDI Compiler 1.1.1 – Dynamic Memory Allocation and Constructors/Destructors</a></li>
<li><a href="print-strings-integers-intel-assembly.html">How to print strings and integers in Intel Assembly on Linux ?</a></li>
<li><a href="../../2012/03/introduction-64-bit-intel-assembly-language-programming-linux-book-review.html">Introduction to 64 Bit Intel Assembly Language Programming for Linux - Book Review</a></li>
<li><a href="../../2012/07/eddi-compiler-1-0-3-inlining-register-allocation.html">EDDI Compiler 1.0.3 - Inlining and register allocation</a></li>
<li><a href="eddi-compiler-0-6-0-arrays.html">EDDI Compiler 0.6.0 : Arrays</a></li>
<li class="navbar-block">
<li class="wicht-navbar-right">
<a target="_blank" title="Follow @wichtounet on Twitter" href="https://twitter.com/wichtounet">
<img src="../../../assets/img/twitter.png" alt="Follow @wichtounet on Twitter"></a>
</li>
<li class="wicht-navbar-right">
<a target="_blank" title="Follow +BaptisteWicht on Google+" href="https://plus.google.com/+BaptisteWicht">
<img src="../../../assets/img/google_plus.png" alt="Follow +BaptisteWicht on Google+"></a>
</li>
</ul>
</div>

</nav>
</div> 
<div class="col-sm-9 col-lg-10">
<div id="content"></div>
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Dynamic memory allocation in Intel Assembly on Linux</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">
Baptiste Wicht
</span></p>
<p class="dateline"><a href="#" rel="bookmark"><time class="published dt-published" datetime="2011-11-29T09:16:26+01:00" itemprop="datePublished" title="2011-11-29 09:16">2011-11-29 09:16</time></a></p>
<p class="commentline">
<a href="dynamic-memory-allocation-intel-assembly-linux.html#disqus_thread" data-disqus-identifier="cache/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html">Comments</a>
</p>
<p class="sourceline"><a href="dynamic-memory-allocation-intel-assembly-linux.wp" class="sourcelink">Source</a></p>
</div>
</header><div class="e-content entry-content" itemprop="articleBody text">
<div>
<p>For the version 0.6.0 of the EDDI Compiler, I have written a simple dynamic memory allocation function in assembly. I did that to avoid using malloc in my assembly code. As this is not an easy subject, this article will explain the main parts of writing this function.</p>
<p>As the EDDI Compiler creates program for Linux platform, this article will focus on writing a little memory allocator for Linux in Intel Assembly.</p>
<p>In this article I will follow the <em>AT&amp;T notation</em>.</p>
<h4>Specifications</h4>
<p>The function works like malloc but is simpler. The specifications are the following ones:</p>
<ul>
<li>We call the function with one argument: the dynamic memory size we need</li>
<li>The function returns the start address of the allocated memory in the <strong>%eax</strong> register</li>
<li>There is no need to deallocate the allocated memory</li>
<li>The size that we ask will generally small and always less than 16384 octets</li>
<li>Having some gaps in the memory is not a problem for now</li>
</ul>
<p>So as you can see there are several limitations to this memory allocator. These limitations are the one I had for EDDI, so I'll follow them in this article.</p>
<h4>Dynamic memory allocation</h4>
<p>In Linux, there are two ways for performing dynamic memory allocation:</p>
<ul>
<li>
<strong>brk</strong>: Increment the size of the data segment after the end of the program. This memory is directly after the program and is always contiguous. It's the easiest way for allocating memory. This technique is not perfect for large blocks of data.</li>
<li>
<strong>mmap</strong>: Creates a new memory mapping in the virtual address space. The kernel gives you memory in virtually every place of the memory.</li>
</ul>
<p>In our case, as we need only small blocks, we will use <strong>brk</strong> to dynamically allocate memory.</p>
<p>We can call these procedures using system calls. In assembly, you can use system calls with interruptions (0x80).</p>
<h4>Implementation</h4>
<p>We need two variables for this function. One to keep track of the remaining size and another one to keep track of the current address of the allocated memory.</p>
<pre class="code literal-block"><span></span><span class="na">.data</span>
<span class="na">.size</span> <span class="no">VIeddi_remaining</span><span class="p">,</span> <span class="mi">4</span>

<span class="nl">VIeddi_remaining:</span>
<span class="na">.long</span> <span class="mi">0</span>
<span class="na">.size</span> <span class="no">VIeddi_current</span><span class="p">,</span> <span class="mi">4</span>

<span class="nl">VIeddi_current:</span>
<span class="na">.long</span> <span class="mi">0</span>
</pre>
<p>Both variables are initialized to 0.</p>
<p>And here is the function I've developed :</p>
<pre class="code literal-block"><span></span><span class="nl">eddi_alloc:</span>
<span class="nf">pushl</span> <span class="nv">%ebp</span>
<span class="nf">movl</span> <span class="nv">%esp</span><span class="p">,</span> <span class="nv">%ebp</span>
<span class="nf">movl</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%ecx</span>
<span class="nf">movl</span> <span class="no">VIeddi_remaining</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">cmpl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%ecx</span>
<span class="nf">jle</span> <span class="no">alloc_normal</span>
<span class="nf">movl</span> <span class="no">$45</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">xorl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">int</span>  <span class="no">$0x80</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%esi</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">addl</span> <span class="no">$16384</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="no">$45</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">int</span>  <span class="no">$0x80</span>
<span class="nf">movl</span> <span class="nv">%esi</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">movl</span> <span class="no">$16384</span><span class="p">,</span> <span class="no">VIeddi_remaining</span>
<span class="nf">movl</span> <span class="nv">%esi</span><span class="p">,</span> <span class="no">VIeddi_current</span>

<span class="nl">alloc_normal:</span>
<span class="nf">movl</span> <span class="no">VIeddi_current</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">movl</span> <span class="no">VIeddi_current</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">addl</span> <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="no">VIeddi_current</span>
<span class="nf">movl</span> <span class="no">VIeddi_remaining</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">subl</span> <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="no">VIeddi_remaining</span>
<span class="nf">leave</span>
<span class="nf">ret</span>
</pre>
<p>I will describe now each part of the alloc function.</p>
<pre class="code literal-block"><span></span><span class="nf">movl</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%ebp</span><span class="p">),</span> <span class="nv">%ecx</span>
<span class="nf">movl</span> <span class="no">VIeddi_remaining</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">cmpl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%ecx</span>
<span class="nf">jle</span> <span class="no">alloc_normal</span>
</pre>
<p>In this part we test if there is enough remaining size for the dynamic memory allocation request. It's equivalent to <em>if(remaining &gt;= size)</em>. If there is enough size, we jump to the normal allocation part :</p>
<pre class="code literal-block"><span></span><span class="nl">alloc_normal:</span>
<span class="nf">movl</span> <span class="no">VIeddi_current</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">movl</span> <span class="no">VIeddi_current</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">addl</span> <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="no">VIeddi_current</span>
<span class="nf">movl</span> <span class="no">VIeddi_remaining</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">subl</span> <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="no">VIeddi_remaining</span>
</pre>
<p>First, we move the current address of memory into the <strong>%eax</strong> register for the return value. Then we add the size of the new allocated block to the current address. Finally we remove the size of the new allocated block from the remaining size. After that, we can leave the function.</p>
<p>The most interesting part is what we do when we have to allocate more memory :</p>
<pre class="code literal-block"><span></span><span class="nf">movl</span> <span class="no">$45</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">xorl</span> <span class="nv">%ebx</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">int</span>  <span class="no">$0x80</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%esi</span>
<span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">addl</span> <span class="no">$16384</span><span class="p">,</span> <span class="nv">%ebx</span>
<span class="nf">movl</span> <span class="no">$45</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">int</span>  <span class="no">$0x80</span>
<span class="nf">movl</span> <span class="no">$16384</span><span class="p">,</span> <span class="no">VIeddi_remaining</span>
<span class="nf">movl</span> <span class="nv">%esi</span><span class="p">,</span> <span class="no">VIeddi_current</span>
</pre>
<p>We start by doing an interruption to execute a system call. The <strong>45</strong> in the <strong>%eax</strong> register indicates a <strong>sys_brk</strong> call. The 0 in the <strong>%ebx</strong> register, indicates that we want the current position of brk space. We save this current position into the <strong>%esi</strong> register. Then we add 16384 bits (4K octets) to this address. We call again the <strong>sys_brk</strong> routine to set the address of the brk space to the calculated address. This is the way to dynamically allocates 4K of memory. Finally, we add 4K to the remaining size in octets and we put the current address (before the add) as the current address.</p>
<h4>Possible improvements</h4>
<p>We should make some optimization if this function has to be invoked frequently. The first interruption (call to sys_brk) has only to be done once. The very first time we need to get the start address. Then, we can use the current address as the base address when we do the new allocation.</p>
<p>Another improvement is to avoid having gaps between the used blocks. For that, we can avoid setting the current address directly to the newly allocated address but just add 4K to the remaining size. The blocks will overlap 2 allocated blocks.</p>
<p>We could also check that the value returned by the <strong>sys_brk</strong> is valid. On error, the procedure can return -1.</p>
<h4>Conclusion</h4>
<p>In this post, we developed a basic dynamic memory allocation function in Intel assembly on the Linux platform. I hope that this information can helps some of you.</p>
<p>Don't hesitate if you have a question or a comment on my implementation.</p>
</div>
</div>
<aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../categories/assembly.html" rel="tag">Assembly</a></li>
<li><a class="tag p-category" href="../../../categories/eddi.html" rel="tag">EDDI</a></li>
<li><a class="tag p-category" href="../../../categories/intel.html" rel="tag">Intel</a></li>
<li><a class="tag p-category" href="../../../categories/linux.html" rel="tag">Linux</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous">
<a href="eddi-compiler-0-6-1.html" rel="prev" title="EDDI Compiler 0.6.1 : Function return types">Previous post</a>
</li>
<li class="next">
<a href="cpp-templates-complete-guide-book.html" rel="next" title="C++ Templates : The Complete Guide - Book Review">Next post</a>
</li>
</ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
<div id="disqus_thread"></div>
<script>
        var disqus_shortname ="blogwichtounet",
            disqus_url="http://baptiste-wicht.com/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html",
        disqus_title="Dynamic memory allocation in Intel Assembly on Linux",
        disqus_identifier="cache/posts/2011/11/dynamic-memory-allocation-intel-assembly-linux.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>
</section></article><script>var disqus_shortname="blogwichtounet";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div> 
</div>

</div>



<footer>
Contents © 2017 <a href="/cdn-cgi/l/email-protection#e3818293978a909786948a808b97a3848e828a8fcd808c8e">Baptiste Wicht</a> - Powered by <a href="http://getnikola.com" rel="nofollow">Nikola</a> - License:
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="padding-left:5px;border-width:0" src="../../../assets/img/cc.png"></a>
<ul class="footer_inline_ul">
<li>
<a href="dynamic-memory-allocation-intel-assembly-linux.wp" id="sourcelink">Source</a>
</li>
</ul></footer><script src="/cdn-cgi/scripts/78d64697/cloudflare-static/email-decode.min.js"></script><script src="../../../assets/js/all-nocdn.js"></script>
</body>
</html>
